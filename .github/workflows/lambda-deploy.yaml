name: Deploy Lambda Functions and Layers

on:
    push:
        branches:
            - main
        paths:
            - 'backend/lambdas/**'
            - 'backend/layers/**'

permissions:
    id-token: write
    contents: read

jobs:
    detect-changes:
        runs-on: ubuntu-latest
        outputs:
            changed-lambdas: ${{ steps.changes.outputs.changed-lambdas }}
            changed-layers: ${{ steps.changes.outputs.changed-layers }}
            has-lambda-changes: ${{ steps.changes.outputs.has-lambda-changes }}
            has-layer-changes: ${{ steps.changes.outputs.has-layer-changes }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 2

            - name: Detect changes
              id: changes
              run: |
                  set -e

                  CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
                  echo "Changed files:"
                  echo "$CHANGED_FILES"

                  # Extract changed lambdas and layers
                  CHANGED_LAMBDAS=$(echo "$CHANGED_FILES" | grep '^backend/lambdas/' | cut -d'/' -f3 | sort -u | grep -v '^$' || true)
                  CHANGED_LAYERS=$(echo "$CHANGED_FILES" | grep '^backend/layers/' | cut -d'/' -f3 | sort -u | grep -v '^$' || true)

                  # Convert to JSON arrays for matrix strategy
                  if [ -n "$CHANGED_LAMBDAS" ]; then
                    LAMBDA_JSON=$(echo "$CHANGED_LAMBDAS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
                    echo "has-lambda-changes=true" >> $GITHUB_OUTPUT
                  else
                    LAMBDA_JSON="[]"
                    echo "has-lambda-changes=false" >> $GITHUB_OUTPUT
                  fi

                  if [ -n "$CHANGED_LAYERS" ]; then
                    LAYER_JSON=$(echo "$CHANGED_LAYERS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
                    echo "has-layer-changes=true" >> $GITHUB_OUTPUT
                  else
                    LAYER_JSON="[]"
                    echo "has-layer-changes=false" >> $GITHUB_OUTPUT
                  fi

                  echo "changed-lambdas=$LAMBDA_JSON" >> $GITHUB_OUTPUT
                  echo "changed-layers=$LAYER_JSON" >> $GITHUB_OUTPUT

                  echo "Lambda changes: $LAMBDA_JSON"
                  echo "Layer changes: $LAYER_JSON"

    deploy-layers:
        runs-on: ubuntu-latest
        needs: detect-changes
        if: needs.detect-changes.outputs.has-layer-changes == 'true'
        permissions:
            id-token: write
            contents: read
        strategy:
            matrix:
                layer: ${{ fromJson(needs.detect-changes.outputs.changed-layers) }}
            fail-fast: false
        outputs:
            layer-versions: ${{ steps.collect-versions.outputs.layer-versions }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: '22'

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ vars.AWS_ROLE_ARN }}
                  role-session-name: GitHubActions-DeployLayers
                  aws-region: ${{ vars.AWS_REGION || 'us-east-2' }}

            - name: Validate layer directory
              run: |
                  set -e
                  LAYER_PATH="backend/layers/${{ matrix.layer }}"

                  if [ ! -d "$LAYER_PATH" ]; then
                    echo "Error: Layer directory $LAYER_PATH does not exist"
                    exit 1
                  fi

                  echo "Validated layer directory: $LAYER_PATH"

            - name: Build and package layer
              id: deploy-layer
              run: |
                  set -e

                  LAYER_NAME="${{ matrix.layer }}"
                  LAYER_PATH="backend/layers/$LAYER_NAME"
                  ZIP_FILE="${LAYER_NAME}.zip"

                  echo "Building layer: $LAYER_NAME"
                  cd "$LAYER_PATH"

                  # Create nodejs directory if it doesn't exist
                  mkdir -p nodejs

                  # Install dependencies if package.json exists in nodejs directory
                  if [ -f "nodejs/package.json" ]; then
                    echo "Installing npm dependencies for layer..."
                    echo "Layer package.json contents:"
                    cat nodejs/package.json
                    
                    cd nodejs
                    
                    # Check if package-lock.json exists
                    if [ -f "package-lock.json" ]; then
                      echo "Found package-lock.json, using npm ci..."
                      npm ci --omit=dev --omit=optional
                    else
                      echo "No package-lock.json found, using npm install..."
                      npm install --omit=dev --omit=optional
                    fi
                    
                    cd ..
                    
                    # Verify installation
                    if [ ! -d "nodejs/node_modules" ]; then
                      echo "Error: npm install failed - no node_modules directory created"
                      echo "Contents of nodejs directory:"
                      ls -la nodejs/
                      exit 1
                    fi
                    
                    echo "Dependencies installed successfully"
                    echo "Installed packages:"
                    ls -la nodejs/node_modules/ | head -20
                    
                  elif [ -f "package.json" ]; then
                    echo "Found package.json in root, copying to nodejs directory..."
                    echo "Layer package.json contents:"
                    cat package.json
                    
                    # Copy package.json to nodejs directory
                    cp package.json nodejs/
                    
                    # Check if package-lock.json exists and copy it too
                    if [ -f "package-lock.json" ]; then
                      echo "Found package-lock.json, copying to nodejs directory..."
                      cp package-lock.json nodejs/
                    fi
                    
                    cd nodejs
                    
                    # Install dependencies
                    if [ -f "package-lock.json" ]; then
                      echo "Running npm ci in nodejs directory..."
                      npm ci --omit=dev --omit=optional
                    else
                      echo "Running npm install in nodejs directory..."
                      npm install --omit=dev --omit=optional
                    fi
                    
                    cd ..
                    
                    # Verify installation
                    if [ ! -d "nodejs/node_modules" ]; then
                      echo "Error: npm install failed - no node_modules directory created"
                      echo "Contents of nodejs directory:"
                      ls -la nodejs/
                      exit 1
                    fi
                    
                    echo "Dependencies installed successfully"
                    echo "Installed packages:"
                    ls -la nodejs/node_modules/ | head -20
                  else
                    echo "No package.json found in root or nodejs directory, creating layer without external dependencies"
                  fi

                  # Copy any custom modules from src/ to nodejs/node_modules/
                  if [ -d "src" ]; then
                    echo "Copying custom modules from src/ directory..."
                    for module_dir in src/*/; do
                      if [ -d "$module_dir" ]; then
                        module_name=$(basename "$module_dir")
                        echo "Copying module: $module_name"
                        mkdir -p "nodejs/node_modules/$module_name"
                        cp -r "$module_dir"* "nodejs/node_modules/$module_name/"
                      fi
                    done
                  fi

                  # Verify nodejs directory structure
                  echo "Layer contents:"
                  find nodejs -type f -name "*.js" -o -name "package.json" | head -20

                  # Create ZIP file excluding development files
                  echo "Creating ZIP package..."
                  zip -r "../../../$ZIP_FILE" nodejs/ \
                    -x "*.git*" "*.DS_Store*" "*__pycache__*" "*.pyc" \
                       "*/test/*" "*/tests/*" "*/.nyc_output/*" \
                       "*/coverage/*" "*/*.md" "*/.eslintrc*" \
                       "*/.gitignore" "*/tsconfig.json"

                  cd - > /dev/null

                  # Verify ZIP contents
                  echo "ZIP file contents (first 20 files):"
                  unzip -l "$ZIP_FILE" | head -20

                  echo "Publishing layer version..."
                  LAYER_VERSION=$(aws lambda publish-layer-version \
                    --layer-name "$LAYER_NAME" \
                    --zip-file "fileb://$ZIP_FILE" \
                    --compatible-runtimes nodejs22.x \
                    --description "Node.js 22.x layer: $LAYER_NAME" \
                    --query 'Version' \
                    --output text)

                  if [ -z "$LAYER_VERSION" ]; then
                    echo "Error: Failed to get layer version"
                    exit 1
                  fi

                  echo "Successfully deployed layer $LAYER_NAME version $LAYER_VERSION"
                  echo "layer-name=$LAYER_NAME" >> $GITHUB_OUTPUT
                  echo "layer-version=$LAYER_VERSION" >> $GITHUB_OUTPUT

                  # Create individual artifact file
                  echo "${LAYER_NAME}:${LAYER_VERSION}" > "layer-version-${LAYER_NAME}.txt"

                  # Cleanup
                  rm "$ZIP_FILE"

            - name: Upload layer version artifact
              uses: actions/upload-artifact@v4
              with:
                  name: layer-version-${{ matrix.layer }}
                  path: layer-version-${{ matrix.layer }}.txt
                  retention-days: 1

    deploy-lambdas:
        runs-on: ubuntu-latest
        needs: [detect-changes, deploy-layers]
        if: always() && needs.detect-changes.outputs.has-lambda-changes == 'true'
        permissions:
            id-token: write
            contents: read
        strategy:
            matrix:
                lambda: ${{ fromJson(needs.detect-changes.outputs.changed-lambdas) }}
            fail-fast: false
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: '22'

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ vars.AWS_ROLE_ARN }}
                  role-session-name: GitHubActions-DeployLambdas
                  aws-region: ${{ vars.AWS_REGION || 'us-east-2' }}

            - name: Validate lambda directory and determine structure
              id: validate-lambda
              run: |
                  set -e
                  LAMBDA_PATH="backend/lambdas/${{ matrix.lambda }}"
                  SRC_PATH="$LAMBDA_PATH/src"

                  # Check if lambda directory exists
                  if [ ! -d "$LAMBDA_PATH" ]; then
                    echo "Error: Lambda directory $LAMBDA_PATH does not exist"
                    exit 1
                  fi

                  # Determine if using src/ structure or root structure
                  if [ -d "$SRC_PATH" ]; then
                    echo "Using src/ structure for lambda ${{ matrix.lambda }}"
                    echo "source-path=$SRC_PATH" >> $GITHUB_OUTPUT
                    echo "use-src-structure=true" >> $GITHUB_OUTPUT
                  else
                    # Check if there are source files directly in the lambda directory
                    if find "$LAMBDA_PATH" -maxdepth 1 -name "*.js" -o -name "*.mjs" -o -name "*.ts" -o -name "index.*" | grep -q .; then
                      echo "Using root structure for lambda ${{ matrix.lambda }}"
                      echo "source-path=$LAMBDA_PATH" >> $GITHUB_OUTPUT
                      echo "use-src-structure=false" >> $GITHUB_OUTPUT
                    else
                      echo "Error: No source files found in $LAMBDA_PATH or $SRC_PATH"
                      echo "Expected either:"
                      echo "  - Source files directly in $LAMBDA_PATH, or"
                      echo "  - Source files in $SRC_PATH"
                      exit 1
                    fi
                  fi

                  echo "Validated lambda directory structure"

            - name: Package and deploy lambda
              run: |
                  set -e

                  LAMBDA_NAME="${{ matrix.lambda }}"
                  LAMBDA_PATH="backend/lambdas/$LAMBDA_NAME"
                  SOURCE_PATH="${{ steps.validate-lambda.outputs.source-path }}"
                  USE_SRC_STRUCTURE="${{ steps.validate-lambda.outputs.use-src-structure }}"
                  ZIP_FILE="${LAMBDA_NAME}-function.zip"

                  echo "Packaging lambda: $LAMBDA_NAME"
                  echo "Source path: $SOURCE_PATH"
                  echo "Using src structure: $USE_SRC_STRUCTURE"

                  cd "$SOURCE_PATH"

                  # Install dependencies if package.json exists in the source directory
                  if [ -f "package.json" ]; then
                    echo "Installing lambda dependencies..."
                    
                    # Use npm ci if package-lock.json exists, otherwise use npm install
                    if [ -f "package-lock.json" ]; then
                      echo "Found package-lock.json, using npm ci..."
                      npm ci --omit=dev --omit=optional
                    else
                      echo "No package-lock.json found, using npm install..."
                      npm install --omit=dev --omit=optional
                    fi
                    
                    # Verify installation
                    if [ ! -d "node_modules" ]; then
                      echo "Warning: npm install completed but no node_modules directory found"
                    else
                      echo "Dependencies installed successfully"
                      echo "Installed packages:"
                      ls -la node_modules/ 2>/dev/null | head -10 || echo "Could not list node_modules contents"
                    fi
                  else
                    echo "No package.json found in source directory"
                  fi

                  # Calculate the relative path back to the root for the ZIP file
                  if [ "$USE_SRC_STRUCTURE" = "true" ]; then
                    ZIP_PATH="../../../../$ZIP_FILE"
                  else
                    ZIP_PATH="../../../$ZIP_FILE"
                  fi

                  # Create ZIP file with all source files
                  echo "Creating ZIP package from $SOURCE_PATH..."
                  zip -r "$ZIP_PATH" . \
                    -x "*.git*" "*.DS_Store*" "*__pycache__*" "*.pyc" \
                       "tests/*" "test/*" "*.md" ".eslintrc*" \
                       ".gitignore" "tsconfig.json" "*.test.js" "*.spec.js"

                  cd - > /dev/null

                  # Verify ZIP contents
                  echo "ZIP file contents (first 20 files):"
                  unzip -l "$ZIP_FILE" | head -20

                  echo "Checking if lambda function exists..."
                  if aws lambda get-function --function-name "$LAMBDA_NAME" >/dev/null 2>&1; then
                    echo "Updating existing lambda function: $LAMBDA_NAME"
                    aws lambda update-function-code \
                      --function-name "$LAMBDA_NAME" \
                      --zip-file "fileb://$ZIP_FILE"
                    
                    # Wait for update to complete
                    echo "Waiting for function update to complete..."
                    aws lambda wait function-updated --function-name "$LAMBDA_NAME"
                    echo "Lambda function $LAMBDA_NAME updated successfully"
                  else
                    echo "Error: Lambda function $LAMBDA_NAME does not exist. Please create it first."
                    exit 1
                  fi

                  # Cleanup
                  rm "$ZIP_FILE"

    update-lambda-layers:
        runs-on: ubuntu-latest
        needs: [detect-changes, deploy-layers, deploy-lambdas]
        if: always() && needs.deploy-layers.result == 'success' && needs.detect-changes.outputs.has-layer-changes == 'true'
        permissions:
            id-token: write
            contents: read
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ vars.AWS_ROLE_ARN }}
                  role-session-name: GitHubActions-UpdateLayers
                  aws-region: ${{ vars.AWS_REGION || 'us-east-2' }}

            - name: Download all layer version artifacts
              uses: actions/download-artifact@v4
              with:
                  pattern: layer-version-*
                  merge-multiple: true

            - name: Update lambda functions with new layer versions
              run: |
                  set -e

                  # Build associative array of layer versions
                  declare -A LATEST_LAYER_VERSIONS

                  echo "Processing layer version files..."
                  for file in layer-version-*.txt; do
                    if [ -f "$file" ]; then
                      echo "Reading $file"
                      while IFS=: read -r NAME VERSION; do
                        if [ -n "$NAME" ] && [ -n "$VERSION" ]; then
                          LATEST_LAYER_VERSIONS[$NAME]=$VERSION
                          echo "Registered layer $NAME with version $VERSION"
                        fi
                      done < "$file"
                    fi
                  done

                  # Get list of changed layers
                  CHANGED_LAYERS_JSON='${{ needs.detect-changes.outputs.changed-layers }}'
                  CHANGED_LAYERS=$(echo "$CHANGED_LAYERS_JSON" | jq -r '.[]')

                  echo "Changed layers: $CHANGED_LAYERS"

                  # Get all lambda functions
                  echo "Fetching all lambda functions..."
                  LAMBDA_FUNCTIONS=$(aws lambda list-functions --query 'Functions[].FunctionName' --output text)

                  if [ -z "$LAMBDA_FUNCTIONS" ]; then
                    echo "No lambda functions found"
                    exit 0
                  fi

                  echo "Found lambda functions: $LAMBDA_FUNCTIONS"

                  # Update each function that uses changed layers
                  for FUNC in $LAMBDA_FUNCTIONS; do
                    echo "Checking function: $FUNC"
                    
                    # Get current function configuration - more robust approach
                    echo "=== DEBUG: Getting function configuration ==="
                    FUNCTION_CONFIG=$(aws lambda get-function --function-name "$FUNC" --query 'Configuration' --output json 2>/dev/null || echo '{}')
                    echo "Function config: $FUNCTION_CONFIG"
                    
                    # Check if layers exist in the configuration
                    HAS_LAYERS=$(echo "$FUNCTION_CONFIG" | jq -r 'has("Layers")')
                    echo "Has layers: $HAS_LAYERS"
                    
                    if [ "$HAS_LAYERS" = "false" ]; then
                      echo "Function $FUNC has no layers, skipping"
                      continue
                    fi
                    
                    # Extract layer ARNs
                    CURRENT_LAYERS=$(echo "$FUNCTION_CONFIG" | jq -r '.Layers[]?.Arn // empty' | tr '\n' ' ')
                    
                    if [ -z "$CURRENT_LAYERS" ]; then
                      echo "Function $FUNC has empty layers array, skipping"
                      continue
                    fi

                    echo "Current layers for $FUNC: $CURRENT_LAYERS"
                    
                    UPDATED=false
                    NEW_LAYER_ARNS=()

                    # Process each current layer
                    for ARN in $CURRENT_LAYERS; do
                      # Extract layer name and base ARN
                      BASE_ARN=$(echo "$ARN" | sed 's/:[0-9]*$//')
                      LAYER_NAME=$(echo "$ARN" | cut -d':' -f7)
                      
                      echo "Processing layer: $LAYER_NAME (ARN: $ARN)"

                      # Check if this layer was changed
                      if echo "$CHANGED_LAYERS" | grep -qx "$LAYER_NAME"; then
                        if [ -n "${LATEST_LAYER_VERSIONS[$LAYER_NAME]:-}" ]; then
                          NEW_ARN="$BASE_ARN:${LATEST_LAYER_VERSIONS[$LAYER_NAME]}"
                          NEW_LAYER_ARNS+=("$NEW_ARN")
                          echo "Will update $LAYER_NAME to version ${LATEST_LAYER_VERSIONS[$LAYER_NAME]}"
                          UPDATED=true
                        else
                          echo "Warning: No version found for changed layer $LAYER_NAME, keeping current"
                          NEW_LAYER_ARNS+=("$ARN")
                        fi
                      else
                        NEW_LAYER_ARNS+=("$ARN")
                        echo "Layer $LAYER_NAME unchanged, keeping current version"
                      fi
                    done

                    # Update function if any layers changed
                    if [ "$UPDATED" = true ]; then
                      echo "Updating function $FUNC with new layer versions..."
                      aws lambda update-function-configuration \
                        --function-name "$FUNC" \
                        --layers "${NEW_LAYER_ARNS[@]}"
                      
                      echo "Waiting for function configuration update to complete..."
                      aws lambda wait function-updated --function-name "$FUNC"
                      echo "Successfully updated function $FUNC"
                    else
                      echo "No layer updates needed for function $FUNC"
                    fi
                  done

                  echo "Layer update process completed"

    cleanup-old-layers:
        runs-on: ubuntu-latest
        needs: [detect-changes, deploy-layers, update-lambda-layers]
        if: always() && needs.deploy-layers.result == 'success' && needs.detect-changes.outputs.has-layer-changes == 'true'
        permissions:
            id-token: write
            contents: read
        steps:
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ vars.AWS_ROLE_ARN }}
                  role-session-name: GitHubActions-CleanupLayers
                  aws-region: ${{ vars.AWS_REGION || 'us-east-2' }}

            - name: Cleanup old layer versions
              run: |
                  set -e

                  # Configuration
                  KEEP_VERSIONS=3  # Number of versions to keep

                  # Get all layer names that were just deployed
                  DEPLOYED_LAYERS_JSON='${{ needs.detect-changes.outputs.changed-layers }}'
                  DEPLOYED_LAYERS=$(echo "$DEPLOYED_LAYERS_JSON" | jq -r '.[]')

                  echo "Cleaning up old versions for deployed layers..."

                  for LAYER_NAME in $DEPLOYED_LAYERS; do
                    echo "Processing layer: $LAYER_NAME"
                    
                    # Get all versions for this layer, sorted by version number (descending)
                    VERSIONS=$(aws lambda list-layer-versions \
                      --layer-name "$LAYER_NAME" \
                      --query 'LayerVersions[].Version' \
                      --output text | tr '\t' '\n' | sort -nr)
                    
                    if [ -z "$VERSIONS" ]; then
                      echo "No versions found for layer $LAYER_NAME"
                      continue
                    fi
                    
                    echo "Found versions for $LAYER_NAME: $(echo $VERSIONS | tr '\n' ' ')"
                    
                    # Skip the first KEEP_VERSIONS versions and delete the rest
                    VERSIONS_TO_DELETE=$(echo "$VERSIONS" | tail -n +$((KEEP_VERSIONS + 1)))
                    
                    if [ -z "$VERSIONS_TO_DELETE" ]; then
                      echo "No old versions to delete for layer $LAYER_NAME"
                      continue
                    fi
                    
                    echo "Deleting old versions for $LAYER_NAME: $(echo $VERSIONS_TO_DELETE | tr '\n' ' ')"
                    
                    for VERSION in $VERSIONS_TO_DELETE; do
                      echo "Deleting layer $LAYER_NAME version $VERSION"
                      aws lambda delete-layer-version \
                        --layer-name "$LAYER_NAME" \
                        --version-number "$VERSION" || {
                        echo "Warning: Failed to delete version $VERSION of layer $LAYER_NAME (may be in use)"
                      }
                    done
                  done

                  echo "Layer cleanup completed"
