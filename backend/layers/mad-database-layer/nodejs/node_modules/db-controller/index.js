import { Pool } from 'pg';

// Rerun action
export class DbController {
	constructor() {
		this.pool = null;
	}

	async getDbConfig() {
		const requiredEnvVars = ['DB_HOST', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'];
		const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);

		if (missing.length > 0) {
			throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
		}

		return {
			host: process.env.DB_HOST,
			port: parseInt(process.env.DB_PORT) || 5432,
			database: process.env.DB_NAME,
			user: process.env.DB_USER,
			password: process.env.DB_PASSWORD,
			ssl: process.env.DB_SSL !== 'false'
		};
	}

	async getPool() {
		if (!this.pool) {
			const config = await this.getDbConfig();

			this.pool = new Pool({
				...config,
				max: 5,
				idleTimeoutMillis: 30000,
				connectionTimeoutMillis: 2000,
				ssl: config.ssl ? { rejectUnauthorized: false } : false
			});

			this.pool.on('error', err => {
				console.error('Unexpected error on idle client', err);
			});
		}

		return this.pool;
	}

	async query(text, params) {
		const pool = await this.getPool();
		const client = await pool.connect();

		try {
			const result = await client.query(text, params);
			return result;
		} finally {
			client.release();
		}
	}

	async transaction(queries) {
		const pool = await this.getPool();
		const client = await pool.connect();

		try {
			await client.query('BEGIN');
			const results = [];

			for (const query of queries) {
				const result = await client.query(query.text, query.params);
				results.push(result);
			}

			await client.query('COMMIT');
			return results;
		} catch (error) {
			await client.query('ROLLBACK');
			throw error;
		} finally {
			client.release();
		}
	}

	async close() {
		if (this.pool) {
			await this.pool.end();
			this.pool = null;
		}
	}
}

const dbConnection = new DbController();

export const query = async (text, params) => {
	return await dbConnection.query(text, params);
};

export const transaction = async queries => {
	return await dbConnection.transaction(queries);
};
