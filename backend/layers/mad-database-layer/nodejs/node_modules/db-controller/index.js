import { Pool } from 'pg';
import AWS from 'aws-sdk';

export class DbController {
	constructor() {
		this.pool = null;
		this.secretsCache = {};
		this.secretsManager = new AWS.SecretsManager();
	}

	async getSecrets(secretName) {
		if (Object.keys(this.secretsCache).includes(secretName)) {
			return this.secretsCache[secretName];
		}

		try {
			const response = await this.secretsManager
				.getSecretValue({
					SecretId: secretName
				})
				.promise();

			const secrets = JSON.parse(response.SecretString);
			this.secretsCache[secretName] = secrets;
			return secrets;
		} catch (error) {
			console.error('Error retrieving secrets:', error);
			throw error;
		}
	}

	async getDbConfig() {
		const secretName = process.env.DB_SECRET_NAME;
		const secrets = await this.getSecrets(secretName);
		return {
			host: secrets.host,
			port: secrets.port || 5432,
			database: secrets.dbname,
			user: secrets.username,
			password: secrets.password,
			ssl: secrets.ssl !== undefined ? secrets.ssl : true
		};
	}

	async getPool() {
		if (!this.pool) {
			const config = await this.getDbConfig();

			this.pool = new Pool({
				...config,
				max: 5,
				idleTimeoutMillis: 30000,
				connectionTimeoutMillis: 2000,
				ssl: config.ssl ? { rejectUnauthorized: false } : false
			});

			this.pool.on('error', err => {
				console.error('Unexpected error on idle client', err);
			});
		}

		return this.pool;
	}

	async query(text, params) {
		const pool = await this.getPool();
		const client = await pool.connect();

		try {
			const result = await client.query(text, params);
			return result;
		} finally {
			client.release();
		}
	}

	async transaction(queries) {
		const pool = await this.getPool();
		const client = await pool.connect();

		try {
			await client.query('BEGIN');
			const results = [];

			for (const query of queries) {
				const result = await client.query(query.text, query.params);
				results.push(result);
			}

			await client.query('COMMIT');
			return results;
		} catch (error) {
			await client.query('ROLLBACK');
			throw error;
		} finally {
			client.release();
		}
	}

	async close() {
		if (this.pool) {
			await this.pool.end();
			this.pool = null;
		}
	}
}

const dbConnection = new DbController();

export const query = async (text, params) => {
	return await dbConnection.query(text, params);
};

export const transaction = async queries => {
	return await dbConnection.transaction(queries);
};
